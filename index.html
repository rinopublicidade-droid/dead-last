<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dead Last ‚Äî Sem Host (Firebase Firestore)</title>
  <style>
    :root { --bg:#0b1020; --card:#121a33; --muted:#8ea0c6; --txt:#e8ecff; --ok:#37d67a; --bad:#ff4d6d; --warn:#ffcc00; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#070a14,#0b1020 40%,#070a14);color:var(--txt)}
    .wrap{max-width:980px;margin:0 auto;padding:16px 14px 48px}
    h1{font-size:18px;margin:0 0 10px;letter-spacing:.2px}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .card{background:rgba(18,26,51,.92);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:14px;box-shadow:0 10px 24px rgba(0,0,0,.28)}
    .card h2{margin:0 0 10px;font-size:14px;color:#cfd8ff}
    .grow{flex:1 1 320px}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    input,select,button{
      width:100%;padding:12px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);color:var(--txt);outline:none
    }
    button{cursor:pointer;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.14);font-weight:650}
    button.primary{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border:none}
    button.ok{background:rgba(55,214,122,.15);border:1px solid rgba(55,214,122,.35)}
    button.bad{background:rgba(255,77,109,.12);border:1px solid rgba(255,77,109,.35)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);font-size:12px;color:#d6ddff}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px}
    @media (min-width:760px){ .grid{grid-template-columns:1fr 1fr} }
    .players{display:flex;flex-direction:column;gap:8px}
    .p{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px;border-radius:14px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.08)}
    .p .left{display:flex;flex-direction:column;gap:2px}
    .name{font-weight:900}
    .tags{display:flex;gap:8px;flex-wrap:wrap}
    .tag{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#dbe2ff}
    .tag.dead{border-color:rgba(255,77,109,.35);background:rgba(255,77,109,.10);color:#ffd7df}
    .tag.me{border-color:rgba(55,214,122,.35);background:rgba(55,214,122,.12)}
    .tag.power{border-color:rgba(255,204,0,.35);background:rgba(255,204,0,.10);color:#fff3b0}
    .tag.ready{border-color:rgba(59,130,246,.35);background:rgba(59,130,246,.12)}
    .phaseBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .phaseTitle{font-size:13px;font-weight:900}
    .timer{font-variant-numeric:tabular-nums;font-weight:900}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .two{display:grid;grid-template-columns:1fr;gap:10px}
    @media (min-width:760px){ .two{grid-template-columns:1.2fr .8fr} }
    .log{white-space:pre-wrap;min-height:140px;max-height:260px;overflow:auto;font-size:12px;line-height:1.35;color:#e7ebff;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.08);padding:10px;border-radius:14px}
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Dead Last (fan-made) ‚Äî sem host (Firestore)</h1>

    <div class="row">
      <div class="card grow">
        <h2>1) Entrar / Criar sala</h2>

        <div class="grid">
          <div>
            <label>Seu nome</label>
            <input id="name" placeholder="Ex.: Lucas" maxlength="24"/>

            <label>C√≥digo da sala</label>
            <input id="roomCode" placeholder="Ex.: ABC123" maxlength="10"/>

            <div class="row" style="margin-top:10px">
              <div style="flex:1 1 160px"><button id="btnCreate" class="primary">Criar sala</button></div>
              <div style="flex:1 1 160px"><button id="btnJoin">Entrar na sala</button></div>
            </div>

            <p class="small muted" style="margin:10px 0 0">
              Sem host: o jogo avan√ßa por regras autom√°ticas (PRONTO + timers + todos votaram).
            </p>
          </div>

          <div>
            <label>Status</label>
            <div class="pill" id="statusPill">Desconectado</div>

            <div class="hr"></div>

            <label>Link r√°pido</label>
            <input id="shareLink" readonly placeholder="vai aparecer quando entrar"/>
            <div class="row" style="margin-top:10px">
              <div style="flex:1 1 160px"><button id="btnCopy" class="ok" disabled>Copiar link</button></div>
              <div style="flex:1 1 160px"><button id="btnLeave" class="bad" disabled>Sair</button></div>
            </div>

            <div class="hr"></div>

            <button id="btnReady" class="primary" disabled>‚úÖ Marcar PRONTO</button>
            <p class="small muted" style="margin:10px 0 0">
              No <b>Lobby</b> e ap√≥s a <b>Revela√ß√£o</b>, todos os vivos marcam PRONTO pra continuar.
            </p>
          </div>
        </div>
      </div>

      <div class="card grow">
        <h2>2) Mesa</h2>

        <div class="phaseBox">
          <div>
            <div class="phaseTitle" id="phaseTitle">Fase: ‚Äî</div>
            <div class="small muted">Rodada: <span id="roundN">‚Äî</span></div>
          </div>
          <div class="pill">‚è±Ô∏è <span class="timer" id="timer">00:00</span></div>
        </div>

        <div class="hr"></div>

        <div class="two">
          <div>
            <h2 style="margin:0 0 10px;font-size:14px;color:#cfd8ff">Jogadores</h2>
            <div class="players" id="players"></div>
          </div>

          <div>
            <h2 style="margin:0 0 10px;font-size:14px;color:#cfd8ff">Seu voto</h2>
            <label>Escolha o alvo</label>
            <select id="voteSelect" disabled></select>
            <div class="row" style="margin-top:10px">
              <div style="flex:1 1 160px"><button id="btnVote" class="primary" disabled>Enviar voto</button></div>
              <div style="flex:1 1 160px"><button id="btnUnvote" disabled>Limpar voto</button></div>
            </div>
            <p class="small muted" style="margin:10px 0 0">
              O voto fica salvo no Firestore (UI n√£o mostra). A rodada revela e resolve automaticamente no fim.
            </p>
          </div>
        </div>

        <div class="hr"></div>

        <h2 style="margin:0 0 10px;font-size:14px;color:#cfd8ff">Log</h2>
        <div class="log" id="log"></div>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <h2>Checklist Firebase</h2>
      <ol class="small muted" style="margin:0; padding-left:18px; line-height:1.5">
        <li><b>Firestore Database</b> criado (Cloud Firestore)</li>
        <li>Authentication ‚Üí habilite <b>Anonymous</b></li>
        <li>Firestore Rules: use um conjunto simples (exemplo no fim do arquivo)</li>
        <li>Hospede no GitHub Pages (ou Firebase Hosting)</li>
      </ol>
      <p class="small muted" style="margin:10px 0 0">
        Para ‚Äúvoto realmente secreto‚Äù, j√° envolve Cloud Functions/criptografia (porque no client puro algu√©m t√©cnico pode bisbilhotar).
      </p>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection,
      deleteDoc, getDocs, serverTimestamp, writeBatch, runTransaction, increment
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    /******************************************************************
     * firebaseConfig (j√° preenchido com o seu)
     ******************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyBgiZy06DDdDn47dvWXU2eFFiaqJbjhc-8",
      authDomain: "dead-last-711de.firebaseapp.com",
      projectId: "dead-last-711de",
      storageBucket: "dead-last-711de.firebasestorage.app",
      messagingSenderId: "320301717724",
      appId: "1:320301717724:web:f17a0f0534c055e65c3c19"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const UI = (id) => document.getElementById(id);

    const elName = UI("name");
    const elRoom = UI("roomCode");
    const statusPill = UI("statusPill");
    const shareLink = UI("shareLink");
    const btnCopy = UI("btnCopy");
    const btnLeave = UI("btnLeave");
    const btnCreate = UI("btnCreate");
    const btnJoin = UI("btnJoin");
    const btnReady = UI("btnReady");

    const phaseTitle = UI("phaseTitle");
    const roundN = UI("roundN");
    const timerEl = UI("timer");
    const playersEl = UI("players");
    const logEl = UI("log");

    const voteSelect = UI("voteSelect");
    const btnVote = UI("btnVote");
    const btnUnvote = UI("btnUnvote");

    const params = new URLSearchParams(location.search);
    const preRoom = params.get("room");
    if (preRoom) elRoom.value = preRoom.toUpperCase();

    let uid = null;
    let roomId = null;
    let room = null;
    let me = null;
    let unsubRoom = null;
    let unsubPlayers = null;
    let timerInt = null;

    // Ajustes de jogo (sem host)
    const NEGOTIATION_SEC = 180;     // 3 min
    const VOTING_SEC = 60;          // 1 min
    const REVEAL_SEC = 18;          // tempo curto pra ler (depois volta pro lobby)
    const MIN_PLAYERS = 3;

    function toast(msg, kind="") {
      const stamp = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
      const prefix = kind==="ok" ? "‚úÖ " : kind==="bad" ? "‚õî " : kind==="warn" ? "‚ö†Ô∏è " : "‚Ä¢ ";
      logEl.textContent = `${prefix}[${stamp}] ${msg}\n` + logEl.textContent;
    }
    function setStatus(text){ statusPill.textContent = text; }
    function setEnabled(el, v){ el.disabled = !v; }

    function fmtMMSS(sec) {
      sec = Math.max(0, Math.floor(sec));
      const m = String(Math.floor(sec/60)).padStart(2,"0");
      const s = String(sec%60).padStart(2,"0");
      return `${m}:${s}`;
    }

    function makeRoomCode() {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out = "";
      for (let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
      return out;
    }
    function cleanCode(code) {
      return (code || "").trim().toUpperCase().replace(/[^A-Z0-9]/g,"").slice(0,10);
    }

    // Cole√ß√µes (se quiser ‚Äúresetar‚Äù dados de testes, basta apagar a collection deadlast_rooms2 no Firestore)
    function roomRef(code) { return doc(db, "deadlast_rooms2", code); }
    function playersCol(code) { return collection(db, "deadlast_rooms2", code, "players"); }
    function votesCol(code) { return collection(db, "deadlast_rooms2", code, "votes"); }

    async function ensureAuth() {
      if (uid) return uid;
      await signInAnonymously(auth);
      return new Promise((resolve) => {
        const off = onAuthStateChanged(auth, (user) => {
          if (user) { uid = user.uid; off(); resolve(uid); }
        });
      });
    }

    function stopLocalTimer(){ if (timerInt) clearInterval(timerInt); timerInt=null; }
    function startLocalTimer(){
      stopLocalTimer();
      timerInt = setInterval(() => {
        if (!room) { timerEl.textContent = "00:00"; return; }
        const phaseEndsAt = room.phaseEndsAtMillis || 0;
        const phase = room.phase || "lobby";
        if (!phaseEndsAt || phase==="lobby") { timerEl.textContent = "00:00"; return; }
        const left = (phaseEndsAt/1000) - (Date.now()/1000);
        timerEl.textContent = fmtMMSS(left);
      }, 250);
    }

    async function renderPlayers(code) {
      const snap = await getDocs(playersCol(code));
      const arr = snap.docs.map(d => ({ id:d.id, ...d.data() }))
        .sort((a,b) => (b.power||0)-(a.power||0) || (a.name||"").localeCompare(b.name||""));

      playersEl.innerHTML = "";
      voteSelect.innerHTML = "";

      const alive = arr.filter(p => p.alive);

      const ph = document.createElement("option");
      ph.value = "";
      ph.textContent = "‚Äî escolha ‚Äî";
      voteSelect.appendChild(ph);

      for (const p of alive) {
        if (p.uid === uid) continue;
        const opt = document.createElement("option");
        opt.value = p.uid;
        opt.textContent = `${p.name} (Poder ${p.power||0})`;
        voteSelect.appendChild(opt);
      }

      for (const p of arr) {
        const div = document.createElement("div");
        div.className = "p";

        const left = document.createElement("div");
        left.className = "left";

        const nm = document.createElement("div");
        nm.className = "name";
        nm.textContent = p.name || "Sem nome";

        const tags = document.createElement("div");
        tags.className = "tags";

        const tPower = document.createElement("span");
        tPower.className = "tag power";
        tPower.textContent = `Poder ${p.power||0}`;
        tags.appendChild(tPower);

        if (p.ready) {
          const t = document.createElement("span");
          t.className = "tag ready";
          t.textContent = "Pronto";
          tags.appendChild(t);
        }

        if (!p.alive) {
          const t = document.createElement("span");
          t.className = "tag dead";
          t.textContent = "Morto";
          tags.appendChild(t);
        }

        if (p.uid === uid) {
          const t = document.createElement("span");
          t.className = "tag me";
          t.textContent = "Voc√™";
          tags.appendChild(t);
        }

        left.appendChild(nm);
        left.appendChild(tags);

        const right = document.createElement("div");
        right.className = "small muted";
        right.textContent = p.alive ? "üü¢ vivo" : "üî¥ fora";

        div.appendChild(left);
        div.appendChild(right);
        playersEl.appendChild(div);
      }

      computeUI();
    }

    function computeUI() {
      const phase = room?.phase || "lobby"; // lobby | negotiation | voting | reveal
      phaseTitle.textContent = `Fase: ${phase}`;
      roundN.textContent = String(room?.round ?? 0);

      const canReady = !!roomId && !!me?.alive && (phase==="lobby" || phase==="reveal");
      setEnabled(btnReady, canReady);

      const canVote = !!roomId && !!me?.alive && phase==="voting";
      setEnabled(voteSelect, canVote);
      setEnabled(btnVote, canVote);
      setEnabled(btnUnvote, canVote);

      setEnabled(btnLeave, !!roomId);
      setEnabled(btnCopy, !!roomId);
    }

    async function upsertMe(code, name) {
      const ref = doc(playersCol(code), uid);
      const snap = await getDoc(ref);
      if (!snap.exists()) {
        await setDoc(ref, {
          uid,
          name,
          alive: true,
          power: 0,
          ready: false,
          joinedAt: serverTimestamp()
        });
        toast(`Voc√™ entrou como "${name}".`, "ok");
      } else {
        const data = snap.data();
        if ((data.name||"") !== name && name) {
          await updateDoc(ref, { name });
          toast(`Nome atualizado: ${name}`, "ok");
        }
      }
    }

    async function setReady(value) {
      if (!roomId || !uid) return;
      await updateDoc(doc(playersCol(roomId), uid), { ready: !!value });
      toast(value ? "Voc√™ marcou PRONTO." : "Voc√™ desmarcou pronto.", "ok");
      await advanceIfNeeded("ready-change");
    }

    async function enterRoom(code, name, creating=false) {
      code = cleanCode(code);
      if (!code) { alert("Informe um c√≥digo de sala."); return; }
      if (!name) { alert("Informe seu nome."); return; }

      await ensureAuth();
      const ref = roomRef(code);
      const snap = await getDoc(ref);

      if (creating) {
        if (snap.exists()) { alert("Sala j√° existe. Use outro c√≥digo."); return; }
        await setDoc(ref, {
          code,
          phase: "lobby",
          round: 0,
          phaseEndsAtMillis: 0,
          voteCount: 0,
          aliveCount: 0,
          readyCount: 0,
          lastResolvedRound: 0,
          revealed: { round:0, eliminatedUid:"", eliminatedName:"", tally:{}, winners:[] },
          createdAt: serverTimestamp()
        });
        toast(`Sala ${code} criada.`, "ok");
      } else {
        if (!snap.exists()) { alert("Sala n√£o encontrada."); return; }
      }

      roomId = code;
      await upsertMe(code, name);

      watchRoom(code);
      computeUI();
    }

    async function leaveRoom() {
      if (!roomId || !uid) return;
      const b = writeBatch(db);
      b.delete(doc(playersCol(roomId), uid));
      b.delete(doc(votesCol(roomId), uid));
      await b.commit();

      unsubRoom?.(); unsubRoom=null;
      unsubPlayers?.(); unsubPlayers=null;

      roomId=null; room=null; me=null;
      playersEl.innerHTML="";
      voteSelect.innerHTML="";
      shareLink.value="";
      phaseTitle.textContent="Fase: ‚Äî";
      roundN.textContent="‚Äî";
      timerEl.textContent="00:00";
      setStatus("Desconectado");
      computeUI();
      toast("Voc√™ saiu.", "warn");
    }

    function watchRoom(code) {
      unsubRoom?.();
      unsubRoom = onSnapshot(roomRef(code), (snap) => {
        room = snap.exists() ? snap.data() : null;
        if (!room) return;

        setStatus(`Conectado ‚Äî Sala ${code}`);
        const url = new URL(location.href);
        url.searchParams.set("room", code);
        shareLink.value = url.toString();

        computeUI();
        startLocalTimer();

        // sempre que a sala mudar, tenta avan√ßar
        advanceIfNeeded("room-snapshot").catch(()=>{});
      });

      unsubPlayers?.();
      unsubPlayers = onSnapshot(playersCol(code), async (snap) => {
        const mine = snap.docs.find(d => d.id === uid);
        me = mine ? mine.data() : null;
        await renderPlayers(code);
        await advanceIfNeeded("players-snapshot");
      });
    }

    /******************************************************************
     * VOTOS (com contagem via transaction)
     ******************************************************************/
    async function sendVote() {
      if (!roomId || !room || !me?.alive) return;
      const phase = room.phase || "lobby";
      if (phase !== "voting") { alert("Ainda n√£o √© fase de vota√ß√£o."); return; }

      const targetUid = voteSelect.value;
      if (!targetUid) { alert("Escolha um alvo."); return; }

      const rRef = roomRef(roomId);
      const vRef = doc(votesCol(roomId), uid);

      await runTransaction(db, async (tx) => {
        const [rSnap, vSnap] = await Promise.all([tx.get(rRef), tx.get(vRef)]);
        if (!rSnap.exists()) throw new Error("Sala n√£o existe.");
        const r = rSnap.data();
        if ((r.phase||"") !== "voting") throw new Error("N√£o est√° em vota√ß√£o.");
        if (vSnap.exists()) return; // j√° votou; travamos pra evitar bagun√ßa

        tx.set(vRef, { voterUid: uid, targetUid, at: serverTimestamp(), round: r.round || 0 });
        tx.update(rRef, { voteCount: increment(1) });
      });

      toast("Voto enviado.", "ok");
      await advanceIfNeeded("vote-sent");
    }

    async function clearMyVote() {
      if (!roomId || !room) return;
      const phase = room.phase || "lobby";
      if (phase !== "voting") { alert("S√≥ d√° pra limpar durante a vota√ß√£o."); return; }

      const rRef = roomRef(roomId);
      const vRef = doc(votesCol(roomId), uid);

      await runTransaction(db, async (tx) => {
        const [rSnap, vSnap] = await Promise.all([tx.get(rRef), tx.get(vRef)]);
        if (!rSnap.exists()) throw new Error("Sala n√£o existe.");
        const r = rSnap.data();
        if ((r.phase||"") !== "voting") throw new Error("N√£o est√° em vota√ß√£o.");
        if (!vSnap.exists()) return;

        tx.delete(vRef);
        tx.update(rRef, { voteCount: increment(-1) });
      });

      toast("Voto removido.", "warn");
      await advanceIfNeeded("vote-cleared");
    }

    /******************************************************************
     * AVAN√áO AUTOM√ÅTICO (SEM HOST)
     ******************************************************************/
    async function syncCounts(code) {
      if (!code) return;
      const [pSnap, rSnap] = await Promise.all([getDocs(playersCol(code)), getDoc(roomRef(code))]);
      if (!rSnap.exists()) return;
      const r = rSnap.data();

      const players = pSnap.docs.map(d=>d.data());
      const alive = players.filter(p=>p.alive);
      const aliveCount = alive.length;
      const readyCount = alive.filter(p=>p.ready).length;

      const needAlive = (r.aliveCount||0) !== aliveCount;
      const needReady = (r.readyCount||0) !== readyCount;
      if (needAlive || needReady) await updateDoc(roomRef(code), { aliveCount, readyCount });
    }

    function pickTieRandom(tiedUids, seedStr) {
      let h = 2166136261;
      for (let i=0;i<seedStr.length;i++) {
        h ^= seedStr.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      const idx = Math.abs(h) % tiedUids.length;
      return tiedUids[idx];
    }

    async function resolveVotingRound(code, roundNumber) {
      const [vSnap, pSnap] = await Promise.all([getDocs(votesCol(code)), getDocs(playersCol(code))]);
      const players = pSnap.docs.map(d => d.data());
      const alive = players.filter(p => p.alive);
      const names = Object.fromEntries(players.map(p => [p.uid, p.name || p.uid.slice(0,6)]));

      const tally = {};
      const votes = [];
      for (const d of vSnap.docs) {
        const v = d.data();
        if ((v.round ?? -1) !== roundNumber) continue;
        const voterAlive = alive.some(p => p.uid === v.voterUid);
        const targetAlive = alive.some(p => p.uid === v.targetUid);
        if (!voterAlive || !targetAlive) continue;
        tally[v.targetUid] = (tally[v.targetUid] || 0) + 1;
        votes.push(v);
      }

      const entries = Object.entries(tally).sort((a,b)=>b[1]-a[1]);
      if (!entries.length) return { eliminatedUid:"", eliminatedName:"", tally:{}, winners:[] };

      const max = entries[0][1];
      const tied = entries.filter(([,c])=>c===max).map(([u])=>u);

      let eliminatedUid = tied[0];
      if (tied.length > 1) eliminatedUid = pickTieRandom(tied, `${code}|r${roundNumber}|${tied.join(",")}`);

      const eliminatedName = names[eliminatedUid] || "?";
      const winners = votes.filter(v => v.targetUid === eliminatedUid).map(v => v.voterUid);

      return { eliminatedUid, eliminatedName, tally, winners };
    }

    async function applyResolutionIfNeeded(code) {
      const rSnap = await getDoc(roomRef(code));
      if (!rSnap.exists()) return;
      const r = rSnap.data();
      if ((r.phase||"") !== "reveal") return;

      const round = r.round || 0;
      if ((r.revealed?.round ?? 0) === round) return;

      const result = await resolveVotingRound(code, round);

      const [pSnap] = await Promise.all([getDocs(playersCol(code))]);
      const players = pSnap.docs.map(d=>d.data());
      const names = Object.fromEntries(players.map(p => [p.uid, p.name || p.uid.slice(0,6)]));

      const b = writeBatch(db);

      if (result.eliminatedUid) {
        b.update(doc(playersCol(code), result.eliminatedUid), { alive:false, ready:false });
      }

      for (const w of result.winners) {
        const p = players.find(x => x.uid === w);
        if (!p || !p.alive) continue;
        b.update(doc(playersCol(code), w), { power: (p.power||0) + 1 });
      }

      // limpa ready dos vivos
      for (const p of players) if (p.alive) b.update(doc(playersCol(code), p.uid), { ready:false });

      // apaga votos e zera contagem
      const vSnap = await getDocs(votesCol(code));
      vSnap.docs.forEach(d => b.delete(d.ref));

      const tallyNamed = {};
      for (const [uidKey, count] of Object.entries(result.tally || {})) {
        tallyNamed[names[uidKey] || uidKey.slice(0,6)] = count;
      }

      b.update(roomRef(code), {
        voteCount: 0,
        revealed: {
          round,
          eliminatedUid: result.eliminatedUid,
          eliminatedName: result.eliminatedName,
          tally: tallyNamed,
          winners: result.winners.map(u=>names[u] || u.slice(0,6))
        }
      });

      await b.commit();

      if (!Object.keys(tallyNamed).length) {
        toast(`Rodada ${round}: ningu√©m votou v√°lido. Ningu√©m foi eliminado.`, "warn");
      } else {
        toast(`üìä Rodada ${round} ‚Äî Apura√ß√£o:`, "ok");
        for (const [n,c] of Object.entries(tallyNamed)) toast(`  ${n}: ${c}`);
        if (result.eliminatedName) toast(`üíÄ Eliminado: ${result.eliminatedName}`, "bad");
        if (result.winners?.length) toast(`‚¨ÜÔ∏è +1 poder: ${result.winners.map(u=>names[u]||u.slice(0,6)).join(", ")}`, "ok");
      }

      // vencedor
      const pSnap2 = await getDocs(playersCol(code));
      const aliveNow = pSnap2.docs.map(d=>d.data()).filter(p=>p.alive);
      if (aliveNow.length === 1) toast(`üèÜ Fim! Vencedor: ${aliveNow[0].name}`, "ok");
    }

    async function moveRevealToLobbyIfReady(code) {
      const rSnap = await getDoc(roomRef(code));
      if (!rSnap.exists()) return;
      const r = rSnap.data();
      if ((r.phase||"") !== "reveal") return;

      const now = Date.now();
      const timeUp = (r.phaseEndsAtMillis||0) && now >= r.phaseEndsAtMillis;
      const aliveCount = r.aliveCount || 0;
      const readyCount = r.readyCount || 0;

      if (aliveCount <= 1) return;

      if (timeUp || (aliveCount > 0 && readyCount >= aliveCount)) {
        await updateDoc(roomRef(code), { phase: "lobby", phaseEndsAtMillis: 0 });
        toast("Voltando ao Lobby. Marquem PRONTO para iniciar a pr√≥xima rodada.", "ok");
      }
    }

    async function advanceIfNeeded(reason="") {
      if (!roomId) return;

      await syncCounts(roomId);

      const rRef = roomRef(roomId);

      await runTransaction(db, async (tx) => {
        const rSnap = await tx.get(rRef);
        if (!rSnap.exists()) return;
        const r = rSnap.data();

        const phase = r.phase || "lobby";
        const now = Date.now();
        const round = r.round || 0;
        const phaseEndsAt = r.phaseEndsAtMillis || 0;

        const aliveCount = r.aliveCount || 0;
        const readyCount = r.readyCount || 0;
        const voteCount = r.voteCount || 0;

        // Lobby -> Negotiation: todos prontos e min players
        if (phase === "lobby") {
          if (aliveCount < MIN_PLAYERS) return;
          if (readyCount >= aliveCount && aliveCount >= MIN_PLAYERS) {
            tx.update(rRef, {
              phase: "negotiation",
              round: round + 1,
              phaseEndsAtMillis: now + (NEGOTIATION_SEC * 1000),
              voteCount: 0
            });
          }
          return;
        }

        // Negotiation -> Voting: timer acabou
        if (phase === "negotiation") {
          if (phaseEndsAt && now >= phaseEndsAt) {
            tx.update(rRef, {
              phase: "voting",
              phaseEndsAtMillis: now + (VOTING_SEC * 1000),
              voteCount: 0
            });
          }
          return;
        }

        // Voting -> Reveal: todos votaram OU timer acabou
        if (phase === "voting") {
          const timeUp = phaseEndsAt && now >= phaseEndsAt;
          const allVoted = aliveCount > 0 && voteCount >= aliveCount;
          const lastResolved = r.lastResolvedRound || 0;
          if ((timeUp || allVoted) && lastResolved < round) {
            tx.update(rRef, {
              phase: "reveal",
              phaseEndsAtMillis: now + (REVEAL_SEC * 1000),
              lastResolvedRound: round
            });
          }
          return;
        }

        // Reveal: resolu√ß√£o fora do tx
      });

      await applyResolutionIfNeeded(roomId);
      await syncCounts(roomId);
      await moveRevealToLobbyIfReady(roomId);
    }

    /******************************************************************
     * BINDINGS
     ******************************************************************/
    btnCreate.addEventListener("click", async () => {
      try {
        const name = elName.value.trim();
        let code = cleanCode(elRoom.value);
        if (!code) { code = makeRoomCode(); elRoom.value = code; }
        await enterRoom(code, name, true);
      } catch (e) { console.error(e); alert(String(e.message||e)); }
    });

    btnJoin.addEventListener("click", async () => {
      try {
        const name = elName.value.trim();
        const code = cleanCode(elRoom.value);
        await enterRoom(code, name, false);
      } catch (e) { console.error(e); alert(String(e.message||e)); }
    });

    btnLeave.addEventListener("click", () => leaveRoom());
    btnCopy.addEventListener("click", async () => {
      try { await navigator.clipboard.writeText(shareLink.value); toast("Link copiado!", "ok"); }
      catch { alert("Copie manualmente."); }
    });

    btnReady.addEventListener("click", async () => {
      if (!me?.alive) return;
      const next = !me?.ready;
      await setReady(next);
    });

    btnVote.addEventListener("click", () => sendVote().catch(e=>alert(e.message)));
    btnUnvote.addEventListener("click", () => clearMyVote().catch(e=>alert(e.message)));

    onAuthStateChanged(auth, (user) => {
      if (user) {
        uid = user.uid;
        setStatus("Autenticado (an√¥nimo) ‚Äî pronto");
        setEnabled(btnCopy, !!roomId);
      } else setStatus("Desconectado");
    });
    ensureAuth().catch(()=>{});

    toast("Crie/entre na sala. No Lobby, TODOS VIVOS marcam PRONTO para iniciar. Sem host üòà", "ok");

    /******************************************************************
     * Regras Firestore (EXEMPLO SIMPLES)
     *
     * ATEN√á√ÉO: como √© uma app client-side, regras muito abertas permitem bagun√ßa.
     * Para jogar entre amigos costuma servir. Se quiser endurecer, eu monto
     * regras melhores + modelo com Cloud Functions.
     *
     * rules_version = '2';
     * service cloud.firestore {
     *   match /databases/{database}/documents {
     *     match /deadlast_rooms2/{roomId} {
     *       allow read: if true;
     *       allow create, update: if request.auth != null;
     *
     *       match /players/{uid} {
     *         allow read: if true;
     *         allow create, update, delete: if request.auth != null && request.auth.uid == uid;
     *       }
     *       match /votes/{uid} {
     *         allow read: if true; // se quiser privacidade, deixe false (mas a√≠ a resolu√ß√£o client n√£o funciona)
     *         allow create, update, delete: if request.auth != null && request.auth.uid == uid;
     *       }
     *     }
     *   }
     * }
     ******************************************************************/
  </script>
</body>
</html>
